<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>conferenceBuddy ‚Äî record locally, upload when ready</title>
<link rel="icon" href="data:;base64,=">
<style>
  :root{--bg:#0b1020;--card:#0f172a;--ink:#e5e7eb;--muted:#94a3b8;--accent:#22c55e;--warn:#f59e0b;--border:#1f2937;}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter}
  .wrap{max-width:960px;margin:auto;padding:20px;display:grid;gap:14px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:16px}
  h1{margin:0 0 8px;font-size:22px}
  h2{margin:0 0 10px;font-size:16px;color:var(--muted)}
  label{display:block;margin:10px 0 6px}
  input,textarea,button{width:100%;padding:12px;border-radius:10px;border:1px solid #263247;background:#0b1220;color:var(--ink)}
  textarea{min-height:120px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .toolbar{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .pill{display:inline-block;padding:6px 10px;border-radius:999px;background:#0b1220;border:1px solid var(--border);color:var(--muted)}
  .ok{color:var(--accent)} .warn{color:var(--warn)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
  .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .thumb{width:100%;aspect-ratio:1/1;object-fit:cover;border-radius:8px;border:1px solid var(--border)}
  .bigbtn{font-size:20px;padding:20px;border-radius:14px}
  .record{background:#dc2626;border:0}
  .stop{background:#16a34a;border:0}
  .imgbtn{background:#2563eb;border:0}
  .uploadbtn{background:#16a34a;border:0}
  .disabled{opacity:.6;pointer-events:none}
  .progress{height:10px;background:#0b1220;border:1px solid var(--border);border-radius:999px;overflow:hidden}
  .bar{height:100%;background:#22c55e;width:0%}
  small{color:var(--muted)}
</style>
<!-- Optional AWS SDK (only used if user provides credentials) -->
<script src="https://sdk.amazonaws.com/js/aws-sdk-2.1481.0.min.js"></script>
</head>
<body>
<div class="wrap">

  <div class="card">
    <h1>conferenceBuddy ‚Äî record locally, upload when ready</h1>
    <p class="mono">S3 layout:
      /conferences/{conference_id}/<br>
      &nbsp;&nbsp;reports/ (empty; external reporting)<br>
      &nbsp;&nbsp;sessions/{session_id}/ session.txt ¬∑ index.txt ¬∑ session_{session_id}.txt<br>
      &nbsp;&nbsp;audio/{session_id}__{timestamp}.m4a (+ .meta.txt)<br>
      &nbsp;&nbsp;images/{session_id}__{timestamp}.jpg (+ .meta.txt)<br>
      &nbsp;&nbsp;notes/{session_id}__{timestamp}.txt (+ .meta.txt)
    </p>
    <small>No transcription. No OCR. Everything saved locally; upload uses either pre-signed URLs or temporary AWS creds you paste below.</small>
  </div>

  <div class="card">
    <h2>1) Session (auto-filled if empty on upload)</h2>
    <div class="row">
      <div><label>Conference ID (UUID)</label><input id="confId" placeholder="auto on upload" /></div>
      <div><label>Session ID (UUID)</label><input id="sessId" placeholder="auto on upload" /></div>
    </div>
    <div class="row">
      <div><label>Conference Name</label><input id="confName" placeholder="auto like 'Conference 2025-09-05'" /></div>
      <div><label>Session Name</label><input id="sessName" placeholder="auto like 'Session 12:34:56'" /></div>
    </div>
    <div class="row">
      <div><label>Vendor (optional)</label><input id="vendorName" placeholder="Vendor" /></div>
      <div><label>Location (optional)</label><input id="location" placeholder="Hall / Booth" /></div>
    </div>
  </div>

  <div class="card">
    <h2>2) Capture</h2>
    <div class="toolbar">
      <button id="recToggle" class="bigbtn record" style="flex:1">‚óè Start Recording</button>
      <button id="imgPickBtn" class="bigbtn imgbtn" style="flex:1">üì∑ Add Image(s)</button>
      <input id="imgPick" type="file" accept="image/*" capture="environment" multiple style="display:none">
    </div>
    <div class="pill" id="recStatus">idle</div>
    <div id="audioList" class="mono" style="margin-top:8px;color:#cbd5e1"></div>
    <label style="margin-top:12px">Notes</label>
    <textarea id="noteText" placeholder="Type notes here... (auto-saved locally)"></textarea>
    <div class="toolbar">
      <button id="addNote">Add Note</button>
      <span id="noteStatus" class="pill">0 notes</span>
    </div>
    <div style="margin-top:10px">
      <div class="grid" id="imgGrid"></div>
    </div>
  </div>

  <div class="card">
    <h2>3) Upload (presigned or pasted creds)</h2>
    <div class="row">
      <div>
        <label>Presign API base (optional)</label>
        <input id="presignBase" placeholder="https://api.example.com/presign" />
        <small>Should accept: POST { key, contentType } ‚Üí { url }</small>
      </div>
      <div>
        <label>S3 Region ¬∑ Bucket</label>
        <input id="region" placeholder="eu-west-2" />
        <input id="bucket" placeholder="confbud" style="margin-top:8px" />
        <small>Needed if you paste AWS creds below. Leave blank for presigned flow.</small>
      </div>
    </div>
    <div class="row">
      <div>
        <label>AWS Access Key (optional)</label>
        <input id="ak" placeholder="AKIA..." />
      </div>
      <div>
        <label>AWS Secret (optional)</label>
        <input id="sk" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢" />
      </div>
    </div>
    <div class="toolbar" style="margin-top:10px">
      <button id="uploadAll" class="uploadbtn bigbtn">‚¨ÜÔ∏è Upload Session</button>
      <span id="uploadHint" class="pill">saves locally even without upload config</span>
    </div>
    <div class="progress" style="margin-top:10px"><div id="overallBar" class="bar"></div></div>
    <div id="log" class="mono" style="white-space:pre-wrap;margin-top:8px;color:var(--muted)"></div>
  </div>

  <div class="card">
    <h2>Local Store</h2>
    <div class="toolbar">
      <button id="saveLocal">üíæ Save Draft</button>
      <button id="loadLocal">üìÇ Load Draft</button>
      <button id="clearLocal">üßπ Clear Draft</button>
      <span id="localStatus" class="pill">unsaved</span>
    </div>
  </div>

</div>

<script>
/* ============ Minimal IndexedDB (no deps) ============ */
const DB_NAME='cbud_db', STORE='draft';
function idbOpen(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=()=>r.result.createObjectStore(STORE); r.onerror=()=>rej(r.error); r.onsuccess=()=>res(r.result); });}
async function idbPut(key,val){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); tx.objectStore(STORE).put(val,key); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); });}
async function idbGet(key){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const req=tx.objectStore(STORE).get(key); req.onsuccess=()=>res(req.result); req.onerror=()=>rej(req.error); });}
async function idbDel(key){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); tx.objectStore(STORE).delete(key); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); });}

/* ============ Utilities ============ */
const $ = s=>document.querySelector(s);
const iso = t=>new Date(t||Date.now()).toISOString().replace(/:/g,'-');
const uuid = ()=> (crypto.randomUUID ? crypto.randomUUID()
  : 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,c=>{const r=Math.random()*16|0,v=c==='x'?r:(r&0x3|0x8);return v.toString(16)}));
const b2f = (blob,name)=> new File([blob], name, {type: blob.type});
const mimeFromName = n => n.endsWith('.jpg')?'image/jpeg':n.endsWith('.m4a')?'audio/mp4':'text/plain';
const log = (...a)=>{ const L=$('#log'); L.textContent += a.join(' ') + '\n'; L.scrollTop=L.scrollHeight; }

/* ============ In-memory session ============ */
let images=[];   // [{file}]
let audios=[];   // [{file}]
let notes=[];    // [{file, body}]
let uploadedKeys=new Set();
let rec=null, recChunks=[];

/* ============ Session helpers ============ */
function ensureAutoFields(){
  if(!$('#confId').value.trim()) $('#confId').value = uuid();
  if(!$('#sessId').value.trim()) $('#sessId').value = uuid();
  const today = new Date().toISOString().slice(0,10);
  if(!$('#confName').value.trim()) $('#confName').value = `Conference ${today}`;
  if(!$('#sessName').value.trim()){
    const t = new Date().toTimeString().split(' ')[0];
    $('#sessName').value = `Session ${t}`;
  }
}
function paths(){
  const conf=$('#confId').value.trim(), sid=$('#sessId').value.trim();
  const base=`conferences/${conf}`;
  return {
    reports:`${base}/reports/`,
    sessDir:`${base}/sessions/${sid}/`,
    sessionTxt:`${base}/sessions/${sid}/session.txt`,
    rollupTxt:`${base}/sessions/${sid}/session_${sid}.txt`,
    indexTxt:`${base}/sessions/${sid}/index.txt`,
    audioDir:`${base}/audio/`,
    imageDir:`${base}/images/`,
    notesDir:`${base}/notes/`
  };
}
function sessionTxt(){
  return [
    `conference_id: ${$('#confId').value.trim()}`,
    `session_id: ${$('#sessId').value.trim()}`,
    `conference_name: ${$('#confName').value.trim()}`,
    `session_name: ${$('#sessName').value.trim()}`,
    `vendor_name: ${$('#vendorName').value.trim()}`,
    `started_at: ${new Date().toISOString()}`,
    `location: ${$('#location').value.trim()}`
  ].join('\n');
}
function meta(kind,name){
  return [
    `id: ${uuid()}`,
    `type: ${kind}`,
    `conference_id: ${$('#confId').value.trim()}`,
    `session_id: ${$('#sessId').value.trim()}`,
    `filename: ${name}`,
    `created_at: ${new Date().toISOString()}`,
    `app_version: 1`,
    `mime: ${mimeFromName(name)}`
  ].join('\n');
}

/* ============ Capture wiring ============ */
$('#imgPickBtn').addEventListener('click', ()=>$('#imgPick').click());
$('#imgPick').addEventListener('change', (e)=>{
  const files=[...e.target.files]; const grid=$('#imgGrid');
  files.forEach(f=>{ images.push({file:f}); const el=document.createElement('img'); el.className='thumb'; el.src=URL.createObjectURL(f); grid.appendChild(el); });
  updatePending();
});

$('#recToggle').addEventListener('click', async ()=>{
  try{
    if(!rec){
      const stream = await navigator.mediaDevices.getUserMedia({audio:true});
      rec = new MediaRecorder(stream);
      rec.ondataavailable = e=> recChunks.push(e.data);
      rec.onstop = ()=>{
        const blob = new Blob(recChunks, {type:'audio/mp4'}); recChunks=[];
        const f = b2f(blob, 'audio_tmp.m4a');
        audios.push({file:f});
        const row=document.createElement('div'); row.textContent=`Audio ${Math.round(f.size/1024)} KB @ ${new Date().toLocaleTimeString()}`;
        $('#audioList').appendChild(row);
        $('#recToggle').classList.remove('stop'); $('#recToggle').classList.add('record');
        $('#recToggle').textContent='‚óè Start Recording'; $('#recStatus').textContent='stopped';
        updatePending();
      };
      rec.start(); $('#recStatus').textContent='recording...';
      $('#recToggle').classList.remove('record'); $('#recToggle').classList.add('stop');
      $('#recToggle').textContent='‚ñ† Stop Recording';
    } else {
      rec.stop(); rec=null;
    }
  }catch(e){ alert('Microphone error: '+(e.message||e)); }
});

$('#addNote').addEventListener('click', ()=>{
  const body=$('#noteText').value.trim(); if(!body) return;
  const blob=new Blob([body],{type:'text/plain'}); const f=b2f(blob,'note_tmp.txt');
  notes.push({file:f, body}); $('#noteText').value=''; $('#noteStatus').textContent=`${notes.length} notes`; updatePending();
});

/* ============ Local Save/Load ============ */
$('#saveLocal').addEventListener('click', async ()=>{
  const payload = {
    v:1,
    fields:{
      confId:$('#confId').value, sessId:$('#sessId').value,
      confName:$('#confName').value, sessName:$('#sessName').value,
      vendorName:$('#vendorName').value, location:$('#location').value
    },
    images: await Promise.all(images.map(async it=>({name:it.file.name, type:it.file.type, buf:await it.file.arrayBuffer()}))),
    audios: await Promise.all(audios.map(async it=>({name:it.file.name, type:it.file.type, buf:await it.file.arrayBuffer()}))),
    notes:  await Promise.all(notes.map(async it=>({name:it.file.name, type:it.file.type, buf:await it.file.arrayBuffer()})))
  };
  await idbPut('draft', payload);
  $('#localStatus').textContent='saved'; $('#localStatus').className='pill ok';
});
$('#loadLocal').addEventListener('click', async ()=>{
  const p = await idbGet('draft'); if(!p){ alert('No draft saved.'); return; }
  $('#confId').value=p.fields.confId||''; $('#sessId').value=p.fields.sessId||'';
  $('#confName').value=p.fields.confName||''; $('#sessName').value=p.fields.sessName||'';
  $('#vendorName').value=p.fields.vendorName||''; $('#location').value=p.fields.location||'';
  images = (p.images||[]).map(o=>({file:new File([o.buf], o.name, {type:o.type})}));
  audios = (p.audios||[]).map(o=>({file:new File([o.buf], o.name, {type:o.type})}));
  notes  = (p.notes ||[]).map(o=>({file:new File([o.buf], o.name, {type:o.type})}));
  $('#imgGrid').innerHTML=''; images.forEach(it=>{ const el=document.createElement('img'); el.className='thumb'; el.src=URL.createObjectURL(it.file); $('#imgGrid').appendChild(el); });
  $('#audioList').innerHTML=''; audios.forEach(it=>{ const row=document.createElement('div'); row.textContent=`Audio ${Math.round(it.file.size/1024)} KB`; $('#audioList').appendChild(row);});
  $('#noteStatus').textContent=`${notes.length} notes`;
  $('#localStatus').textContent='loaded'; $('#localStatus').className='pill ok';
  updatePending();
});
$('#clearLocal').addEventListener('click', async ()=>{
  images=[]; audios=[]; notes=[]; uploadedKeys.clear();
  $('#imgGrid').innerHTML=''; $('#audioList').innerHTML='';
  $('#noteStatus').textContent='0 notes'; await idbDel('draft');
  $('#localStatus').textContent='cleared'; $('#localStatus').className='pill';
  updatePending();
});

/* ============ Upload plumbing (presigned or AWS SDK) ============ */
function useAwsSdk(){
  const ak=$('#ak').value.trim(), sk=$('#sk').value.trim(), region=$('#region').value.trim(), bucket=$('#bucket').value.trim();
  if(!ak || !sk || !region || !bucket) return null;
  AWS.config.update({region, credentials:new AWS.Credentials(ak, sk)});
  return new AWS.S3({apiVersion:'2006-03-01', params:{Bucket:bucket}});
}
async function presignPut(url, file, onProgress){
  return new Promise((res,rej)=>{
    const xhr=new XMLHttpRequest(); xhr.open('PUT', url, true);
    xhr.upload.onprogress = e=>{ if(e.lengthComputable){ onProgress(e.loaded/e.total); } };
    xhr.onload = ()=> xhr.status>=200&&xhr.status<300 ? res() : rej(new Error('HTTP '+xhr.status));
    xhr.onerror=()=>rej(new Error('Network'));
    xhr.setRequestHeader('Content-Type', file.type || 'application/octet-stream');
    xhr.send(file);
  });
}
async function getPresignedUrl(base, key, contentType){
  const r = await fetch(base, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key, contentType})});
  if(!r.ok) throw new Error('presign failed');
  const j = await r.json();
  return j.url || j.signedUrl || j.presignedUrl;
}
async function uploadOne({Key, File, ContentType}, cfg){
  // prefer AWS SDK if configured; else presigned
  if(cfg.s3){
    return new Promise((res,rej)=>{
      const req = cfg.s3.upload({Bucket:cfg.bucket, Key, Body:File, ContentType});
      req.on('httpUploadProgress', e=> cfg.onProgress(e.loaded/e.total));
      req.send((err,data)=> err?rej(err):(uploadedKeys.add(Key),res(data)));
    });
  } else if(cfg.presignBase){
    const url = await getPresignedUrl(cfg.presignBase, Key, ContentType);
    await presignPut(url, File, cfg.onProgress);
    uploadedKeys.add(Key);
  } else {
    throw new Error('No upload method configured (paste AWS creds or set Presign API).');
  }
}

/* ============ Upload runner ============ */
$('#uploadAll').addEventListener('click', async ()=>{
  try{
    ensureAutoFields();
    const P = paths();
    const conf=$('#confId').value.trim(); const sid=$('#sessId').value.trim();

    // Build config
    const s3 = useAwsSdk(); const cfg = {
      s3, bucket: $('#bucket').value.trim(),
      presignBase: $('#presignBase').value.trim(),
      onProgress: p => { /* per-file prog; aggregated below */ }
    };
    let total = images.length + audios.length + notes.length + 4; // +4 meta/session files
    let done = 0;
    const tick = () => { done++; const pct=Math.round(done/total*100); $('#overallBar').style.width=pct+'%'; };

    const ts = ()=> iso();
    // helper wrapper that updates overall progress
    const up = async (Key, File, ContentType)=>{
      let localProg=0;
      await uploadOne({Key, File, ContentType}, {...cfg, onProgress:(p)=>{ if(p>localProg){ localProg=p; } }});
      tick();
      log('Uploaded', Key);
    };

    // session scaffolding files
    await up(`${P.reports}.keep`, new Blob([''],{type:'text/plain'}), 'text/plain');
    await up(P.sessionTxt, new Blob([sessionTxt()],{type:'text/plain'}), 'text/plain');
    await up(P.rollupTxt, new Blob([`counts: {images:0, audio:0, notes:0}\n`+sessionTxt()],{type:'text/plain'}),'text/plain');
    await up(P.indexTxt, new Blob([''],{type:'text/plain'}),'text/plain');

    let imgN=0,audN=0,noteN=0;

    // IMAGES
    for(const it of images){
      const name = `${sid}__${ts()}.jpg`;
      await up(`${P.imageDir}${name}`, it.file, 'image/jpeg');
      await up(`${P.imageDir}${name.replace(/\.jpg$/,'.meta.txt')}`, new Blob([meta('image', name)],{type:'text/plain'}),'text/plain');
      imgN++;
    }
    // AUDIO
    for(const it of audios){
      const name = `${sid}__${ts()}.m4a`;
      await up(`${P.audioDir}${name}`, it.file, 'audio/mp4');
      await up(`${P.audioDir}${name.replace(/\.m4a$/,'.meta.txt')}`, new Blob([meta('audio', name)],{type:'text/plain'}),'text/plain');
      audN++;
    }
    // NOTES
    for(const it of notes){
      const name = `${sid}__${ts()}.txt`;
      await up(`${P.notesDir}${name}`, it.file, 'text/plain');
      await up(`${P.notesDir}${name.replace(/\.txt$/,'.meta.txt')}`, new Blob([meta('note', name)],{type:'text/plain'}),'text/plain');
      noteN++;
    }

    // Update rollup & index at end
    const rollup=[`counts: {images:${imgN}, audio:${audN}, notes:${noteN}}`, sessionTxt()].join('\n');
    await up(P.rollupTxt, new Blob([rollup],{type:'text/plain'}),'text/plain');
    const indexText = Array.from(uploadedKeys).filter(k=>k.startsWith(`conferences/${conf}/`)).join('\n');
    await up(P.indexTxt, new Blob([indexText],{type:'text/plain'}),'text/plain');

    $('#uploadHint').textContent=`Uploaded ${imgN+audN+noteN} items`; $('#uploadHint').className='pill ok';
  }catch(e){
    $('#uploadHint').textContent='upload failed'; $('#uploadHint').className='pill warn';
    log('Upload error:', e.message||e);
  }
});

/* ============ small helpers ============ */
function updatePending(){
  const n=images.length+audios.length+notes.length;
  $('#uploadHint').textContent = `${n} items pending`;
}

/* ============ Boot ============ */
(function boot(){
  updatePending();
})();
</script>
</body>
</html>
